getgenv().LibraryColor = "#B482FF" -- Accent Color of your notfications, feel free to change
loadstring(game:HttpGet("https://raw.githubusercontent.com/64thlol/Marks/refs/heads/main/WASD"))()
local libraryCodeUrl = "https://raw.githubusercontent.com/64thlol/was/refs/heads/main/New%20UI"
local library, utility, obelus = loadstring(game:HttpGet(libraryCodeUrl))()

local window = library:Window({name = "Velo.cc"})

local Aim = window:Page({Name = "Aim"})
local Visual = window:Page({Name = "Visual"})
local Misc = window:Page({Name = "Misc"})
local Settings = window:Page({Name = "Settings"})

--Silent Aim
local section1 = Aim:Section({
    Name = "Silent Aim",
    Side = "Right",
    Size = 450  -- or any height you want
})

-- // Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local Workspace = game:GetService("Workspace")

-- // Vars
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()
local Camera = Workspace.CurrentCamera

-- // Config (default values)
getgenv().Aiming = {
    Enabled = false,
    ShowFOV = false,
    FOVRadius = 150,
    FOVSides = 64,
    FOVColor = Color3.fromRGB(255, 255, 255),
    HitChance = 100,
    VisibleCheck = true,
    ShowSnapline = false,
}

local Aiming = getgenv().Aiming

-- // Drawing objects
local circle = Drawing.new("Circle")
circle.Color = Aiming.FOVColor
circle.Thickness = 2
circle.Filled = false
circle.Transparency = 1
circle.NumSides = Aiming.FOVSides
circle.Visible = Aiming.ShowFOV

local snapLine = Drawing.new("Line")
snapLine.Color = Aiming.FOVColor
snapLine.Thickness = 2
snapLine.Transparency = 1
snapLine.Visible = false

-- // Update FOV circle
function UpdateCircle()
    circle.Visible = Aiming.ShowFOV
    circle.Radius = Aiming.FOVRadius
    circle.Position = Vector2.new(Mouse.X, Mouse.Y + GuiService:GetGuiInset().Y)
end

function IsPartVisible(part, character)
    local origin = Camera.CFrame.Position
    local direction = part.Position - origin
    local rayParams = RaycastParams.new()
    rayParams.FilterType = Enum.RaycastFilterType.Blacklist
    rayParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
    local result = Workspace:Raycast(origin, direction, rayParams)
    return not result or result.Instance:IsDescendantOf(character)
end

function GetClosestPartToMouse(character)
    local closestPart, shortestDistance = nil, math.huge
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            if part.Name == "LeftLeg" or part.Name == "RightLeg" or part.Name == "LeftArm" or part.Name == "RightArm" then continue end
            local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
            if onScreen then
                local dist = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
                if dist < shortestDistance then
                    shortestDistance = dist
                    closestPart = part
                end
            end
        end
    end
    return closestPart
end

function GetClosestPlayer()
    local closestPlayer, closestPart, shortestDistance = nil, nil, math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player == LocalPlayer then continue end
        local character = player.Character
        if not character then continue end
        local part = GetClosestPartToMouse(character)
        if not part then continue end
        if Aiming.VisibleCheck and not IsPartVisible(part, character) then continue end
        local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
        if not onScreen then continue end
        local dist = (Vector2.new(screenPos.X, screenPos.Y) - Vector2.new(Mouse.X, Mouse.Y)).Magnitude
        if dist < Aiming.FOVRadius and dist < shortestDistance then
            closestPlayer = player
            shortestDistance = dist
            closestPart = part
        end
    end
    return closestPlayer, closestPart
end

-- // Hook
local __index
__index = hookmetamethod(game, "__index", function(t, k)
    if t:IsA("Mouse") and (k == "Hit" or k == "Target") and Aiming.Enabled then
        local player, part = GetClosestPlayer()
        if player and part and math.random(0, 100) <= Aiming.HitChance then
            return (k == "Hit" and part.CFrame or part)
        end
    end
    return __index(t, k)
end)

-- // Update loop
RunService.RenderStepped:Connect(function()
    UpdateCircle()

    if Aiming.Enabled and Aiming.ShowSnapline then
        local player, part = GetClosestPlayer()
        if player and part then
            local character = player.Character
            local torso = character and character:FindFirstChild("HumanoidRootPart")
            local targetPart = torso or part

            local screenPos, onScreen = Camera:WorldToViewportPoint(targetPart.Position)
            if onScreen then
                snapLine.Visible = true
                snapLine.From = Vector2.new(Mouse.X, Mouse.Y + GuiService:GetGuiInset().Y)
                snapLine.To = Vector2.new(screenPos.X, screenPos.Y + GuiService:GetGuiInset().Y)
            else
                snapLine.Visible = false
            end
        else
            snapLine.Visible = false
        end
    else
        snapLine.Visible = false
    end
end)

-- // UI Integrations (your style)
section1:Toggle({
    Name = "Enable Silent Aim",
    Default = false,
    Callback = function(state)
        Aiming.Enabled = state
    end
})

section1:Toggle({
    Name = "Enable Silent FOV",
    Default = false,
    Callback = function(state)
        Aiming.ShowFOV = state
        circle.Visible = state
    end
})

section1:Toggle({
    Name = "Enable FOV Snapline",
    Default = false,
    Callback = function(state)
        Aiming.ShowSnapline = state
    end
})

section1:Slider({
    Name = "Hit Chance",
    Min = 0,
    Max = 100,
    Default = 100,
    Callback = function(value)
        Aiming.HitChance = value
    end
})

section1:Slider({
    Name = "Silent Radius",
    Min = 0,
    Max = 500,
    Default = 150,
    Callback = function(value)
        Aiming.FOVRadius = value
    end
})





--Tbot
section1:Label({Name = "Trigger Bot"})

-- // Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UIS = game:GetService("UserInputService")

-- // Vars
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

getgenv().Triggerbot = {
    Enabled = false,
    KnifeCheck = false,
    InitialDelay = 0,
    RepeatDelay = 0,
}

local TriggerSettings = getgenv().Triggerbot

-- // Function to check if mouse target is a player and valid
function GetTarget()
    local target = Mouse.Target
    if not target then return nil end

    local character = target:FindFirstAncestorOfClass("Model")
    if not character then return nil end

    local player = Players:GetPlayerFromCharacter(character)
    if not player or player == LocalPlayer then return nil end

    -- Knife check
    if TriggerSettings.KnifeCheck and player.Character then
        local tool = player.Character:FindFirstChildOfClass("Tool")
        if tool and tool.Name == "Knife" then
            return nil
        end
    end

    return player
end

-- // Trigger loop
RunService.RenderStepped:Connect(function()
    if TriggerSettings.Enabled then
        local tool = LocalPlayer.Character and LocalPlayer.Character:FindFirstChildOfClass("Tool")
        if not tool then return end

        local playerTarget = GetTarget()
        if playerTarget then
            task.wait(TriggerSettings.InitialDelay / 100) -- Convert to smaller scale
            tool:Activate()
            task.wait(TriggerSettings.RepeatDelay / 100) -- Repeat delay
        end
    end
end)

-- // UI Integrations
section1:Toggle({
    Name = "Enable Triggerbot",
    Default = false,
    Callback = function(state)
        TriggerSettings.Enabled = state
    end
})

section1:Toggle({
    Name = "Knife Check",
    Default = false,
    Callback = function(state)
        TriggerSettings.KnifeCheck = state
    end
})

section1:Slider({
    Name = "Delay",
    Min = 0,
    Max = 100,
    Default = 0,
    Callback = function(value)
        TriggerSettings.InitialDelay = value
    end
})

section1:Slider({
    Name = "Delay between each shot",
    Min = 0,
    Max = 100,
    Default = 0,
    Callback = function(value)
        TriggerSettings.RepeatDelay = value
    end
})

--Aimlock

local section2 = Aim:Section({
    Name = "Aimlock",
    Side = "Left",
    Size = 450  -- or any height you want
})

local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Stats = game:GetService("Stats")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Workspace = workspace

local aimlockEnabled = false
local aimlockKeyHeld = false
local aimlockToggleActive = false
local toggleAimbot = false
local wallCheckEnabled = false
local pingPredictionEnabled = false
local aimlockKey = Enum.KeyCode.LeftShift
local aimlockSmoothness = 50
local predictionAmount = 0
local lockedTarget = nil

local function hasLineOfSight(origin, targetPos, targetCharacter)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, targetCharacter}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.IgnoreWater = true

    local direction = targetPos - origin
    local result = Workspace:Raycast(origin, direction, raycastParams)
    return not result
end

local function getClosestTarget()
    local target
    local smallestAngle = math.rad(30)

    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Head") and player.Character:FindFirstChild("Humanoid") then
            local humanoid = player.Character.Humanoid
            if humanoid.Health > 0 then
                local head = player.Character.Head
                local headPos = head.Position
                local direction = (headPos - Camera.CFrame.Position).unit
                local cameraLook = Camera.CFrame.LookVector
                local angle = math.acos(cameraLook:Dot(direction))

                if angle < smallestAngle then
                    if wallCheckEnabled then
                        if hasLineOfSight(Camera.CFrame.Position, headPos, player.Character) then
                            smallestAngle = angle
                            target = head
                        end
                    else
                        smallestAngle = angle
                        target = head
                    end
                end
            end
        end
    end
    return target
end

local aimlockConnection

local function startAimlock()
    if aimlockConnection then return end
    if not lockedTarget then
        local newTarget = getClosestTarget()
        if newTarget then
            lockedTarget = newTarget
        end
    end

    aimlockConnection = RunService.RenderStepped:Connect(function()
        if aimlockEnabled and (aimlockKeyHeld or aimlockToggleActive) and lockedTarget then
            if not lockedTarget.Parent or not lockedTarget:IsDescendantOf(workspace) then
                lockedTarget = nil
                return
            end

            local targetPos = lockedTarget.Position
            local humanoidRootPart = lockedTarget.Parent:FindFirstChild("HumanoidRootPart")
            local predictedPos = targetPos

            if humanoidRootPart then
                local velocity = humanoidRootPart.Velocity
                local dynamicPrediction = predictionAmount

                if pingPredictionEnabled then
                    local pingStr = Stats.Network.ServerStatsItem["Data Ping"]:GetValueString()
                    local ping = tonumber(string.match(pingStr, "%d+")) or 0
                    dynamicPrediction = (ping / 1000) * 1.1
                end

                predictedPos = targetPos + velocity * dynamicPrediction
            end

            local cameraPos = Camera.CFrame.Position
            local desiredLook = (predictedPos - cameraPos).unit
            local currentLook = Camera.CFrame.LookVector
            local alpha = aimlockSmoothness / 100
            local newLook = currentLook:Lerp(desiredLook, alpha)

            Camera.CFrame = CFrame.new(cameraPos, cameraPos + newLook)
        end
    end)
end

local function stopAimlock()
    if aimlockConnection then
        aimlockConnection:Disconnect()
        aimlockConnection = nil
    end
    lockedTarget = nil
end

section2:Toggle({
    Name = "Toggle System",
    Default = false,
    Callback = function(state)
        toggleAimbot = state
        if not toggleAimbot then
            aimlockToggleActive = false
            aimlockKeyHeld = false
            stopAimlock()
        end
    end
})

section2:Toggle({ 
    Name = "Enable Aimlock", 
    Default = false,
    Callback = function(state)
        aimlockEnabled = state
        if not aimlockEnabled then
            aimlockToggleActive = false
            aimlockKeyHeld = false
            stopAimlock()
        else
            startAimlock()
        end
    end
})

section2:Toggle({
    Name = "Ping Based Prediction",
    Default = false,
    Callback = function(state)
        pingPredictionEnabled = state
        if state then
            LibraryNotify("Ping prediction enabled. Auto-adjusting prediction...", 3)
        else
            LibraryNotify("Ping prediction disabled. Manual prediction active.", 3)
        end
    end
})

section2:Toggle({
    Name = "Wall Check",
    Default = false,
    Callback = function(state)
        wallCheckEnabled = state
    end
})

section2:Button({
    Name = "Keybind",
    Callback = function()
        LibraryNotify("Selecting aimlock keybind...", 5)

        if _G.currentHoldConn then _G.currentHoldConn:Disconnect() _G.currentHoldConn = nil end
        if _G.currentReleaseConn then _G.currentReleaseConn:Disconnect() _G.currentReleaseConn = nil end

        local inputConn
        inputConn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed or input.UserInputType ~= Enum.UserInputType.Keyboard then return end

            aimlockKey = input.KeyCode
            LibraryNotify("Aimlock keybind set to: " .. aimlockKey.Name, 10)
            inputConn:Disconnect()

            if _G.currentHoldConn then _G.currentHoldConn:Disconnect() _G.currentHoldConn = nil end
            if _G.currentReleaseConn then _G.currentReleaseConn:Disconnect() _G.currentReleaseConn = nil end

            _G.currentHoldConn = UserInputService.InputBegan:Connect(function(i)
                if i.UserInputType == Enum.UserInputType.Keyboard and i.KeyCode == aimlockKey then
                    if toggleAimbot then
                        aimlockToggleActive = not aimlockToggleActive
                        if aimlockToggleActive then
                            aimlockEnabled = true
                            startAimlock()
                        else
                            stopAimlock()
                        end
                    else
                        aimlockKeyHeld = true
                        startAimlock()
                    end
                end
            end)

            _G.currentReleaseConn = UserInputService.InputEnded:Connect(function(i)
                if i.UserInputType == Enum.UserInputType.Keyboard and i.KeyCode == aimlockKey then
                    if not toggleAimbot then
                        aimlockKeyHeld = false
                        stopAimlock()
                    end
                end
            end)
        end)
    end
})

section2:Slider({ 
    Name = "Aimlock Smoothness", 
    Min = 0,
    Max = 100,
    Default = 50,
    Callback = function(value)
        aimlockSmoothness = value
    end
})

section2:Slider({ 
    Name = "Prediction", 
    Min = 0,
    Max = 25,
    Default = 0,
    Callback = function(value)
        predictionAmount = value
    end
})


section2:Label({Name = "Mouse Spoofer"})


-- // Services
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local Stats = game:GetService("Stats")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera
local Workspace = workspace

-- Settings
local mouseSpooferEnabled = false
local mouseSpooferLocked = false
local currentSpooferTarget = nil
local aimPart = "Torso"
local predictionAmount = 0
local pingPredictionEnabled = false
local radius = 100
local showRadius = false
local aimlockKey = Enum.KeyCode.LeftShift

-- Get part by name
local function getAimPart(character, partName)
    if not character then return nil end
    if partName == "Torso" then
        return character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Torso") or character:FindFirstChild("UpperTorso")
    elseif partName == "Head" then
        return character:FindFirstChild("Head")
    elseif partName == "Left Leg" then
        return character:FindFirstChild("LeftUpperLeg") or character:FindFirstChild("Left Leg")
    elseif partName == "Right Leg" then
        return character:FindFirstChild("RightUpperLeg") or character:FindFirstChild("Right Leg")
    end
    return nil
end

-- Adjust aim offset
local function getAdjustedPosition(part, partName)
    if not part then return nil end
    local pos = part.Position
    if partName == "Head" then
        return pos - Vector3.new(0, 0.15, 0)
    elseif partName == "Left Leg" or partName == "Right Leg" then
        return pos + Vector3.new(0, 0.3, 0)
    elseif partName == "Torso" then
        return pos
    else
        return pos
    end
end

-- Closest target finder
local function getClosestTarget()
    local closestPlayer = nil
    local shortestDistance = radius
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("Humanoid") and player.Character.Humanoid.Health > 0 then
            local part = getAimPart(player.Character, aimPart)
            if part then
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                if onScreen then
                    local mousePos = Vector2.new(UserInputService:GetMouseLocation().X, UserInputService:GetMouseLocation().Y)
                    local part2D = Vector2.new(screenPos.X, screenPos.Y)
                    local dist = (mousePos - part2D).Magnitude
                    if dist < shortestDistance then
                        shortestDistance = dist
                        closestPlayer = player
                    end
                end
            end
        end
    end
    return closestPlayer
end

-- Spoofer Logic
local mouseSpooferConnection
local function startMouseSpoofer()
    if mouseSpooferConnection then return end
    mouseSpooferConnection = RunService.RenderStepped:Connect(function()
        if mouseSpooferEnabled and mouseSpooferLocked then
            if currentSpooferTarget and currentSpooferTarget.Character and currentSpooferTarget.Character:FindFirstChild("Humanoid") and currentSpooferTarget.Character.Humanoid.Health > 0 then
                local part = getAimPart(currentSpooferTarget.Character, aimPart)
                if part then
                    local predictedPos = getAdjustedPosition(part, aimPart) + (part.Velocity * predictionAmount)
                    local screenPos, onScreen = Camera:WorldToViewportPoint(predictedPos)
                    if onScreen then
                        local deltaX = screenPos.X - UserInputService:GetMouseLocation().X
                        local deltaY = screenPos.Y - UserInputService:GetMouseLocation().Y
                        mousemoverel(deltaX, deltaY)
                    else
                        mouseSpooferLocked = false
                        currentSpooferTarget = nil
                    end
                else
                    mouseSpooferLocked = false
                    currentSpooferTarget = nil
                end
            else
                mouseSpooferLocked = false
                currentSpooferTarget = nil
            end
        end
    end)
end

local function stopMouseSpoofer()
    if mouseSpooferConnection then
        mouseSpooferConnection:Disconnect()
        mouseSpooferConnection = nil
    end
    mouseSpooferLocked = false
    currentSpooferTarget = nil
end

-- Aimlock Keybind
UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    if input.UserInputType == Enum.UserInputType.Keyboard and input.KeyCode == aimlockKey then
        if not mouseSpooferEnabled then return end
        if mouseSpooferLocked then
            mouseSpooferLocked = false
            currentSpooferTarget = nil
        else
            currentSpooferTarget = getClosestTarget()
            if currentSpooferTarget then
                mouseSpooferLocked = true
            end
        end
    end
end)

-- UI Toggles
section2:Toggle({
    Name = "Enable Mouse Spoofer",
    Default = false,
    Callback = function(state)
        mouseSpooferEnabled = state
        if state then
            startMouseSpoofer()
        else
            stopMouseSpoofer()
        end
    end
})

section2:Toggle({
    Name = "Show Radius FOV",
    Default = false,
    Callback = function(state)
        showRadius = state
    end
})

section2:Toggle({
    Name = "Ping Based Prediction",
    Default = false,
    Callback = function(state)
        pingPredictionEnabled = state
        if not state then
            LibraryNotify("Ping prediction disabled. Manual prediction active.", 3)
        else
            LibraryNotify("Ping prediction enabled. Auto-adjusting...", 3)
        end
    end
})

section2:Button({
    Name = "Set Keybind",
    Callback = function()
        LibraryNotify("Press a key to set mouse spoofer keybind", 5)
        local conn
        conn = UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed or input.UserInputType ~= Enum.UserInputType.Keyboard then return end
            aimlockKey = input.KeyCode
            LibraryNotify("Mouse spoofer keybind set to: " .. aimlockKey.Name, 5)
            conn:Disconnect()
        end)
    end
})

section2:Slider({
    Name = "Prediction",
    Min = 0,
    Max = 1,
    Default = 0,
    Float = true,
    Callback = function(value)
        predictionAmount = value
    end
})

section2:Slider({
    Name = "Radius",
    Min = 10,
    Max = 300,
    Default = 100,
    Callback = function(value)
        radius = value
    end
})

-- Aim Part Buttons
section2:Button({ Name = "Head", Callback = function()
    aimPart = "Head" LibraryNotify("Mouse spoofer aim part set to Head", 3)
end })

section2:Button({ Name = "Torso", Callback = function()
    aimPart = "Torso" LibraryNotify("Mouse spoofer aim part set to Torso", 3)
end })

section2:Button({ Name = "Left Leg", Callback = function()
    aimPart = "Left Leg" LibraryNotify("Mouse spoofer aim part set to Left Leg", 3)
end })

section2:Button({ Name = "Right Leg", Callback = function()
    aimPart = "Right Leg" LibraryNotify("Mouse spoofer aim part set to Right Leg", 3)
end })

-- Draw white radius FOV
local circle = Drawing.new("Circle")
circle.Visible = false
circle.Transparency = 0.5
circle.Color = Color3.new(1, 1, 1)
circle.Thickness = 2
circle.Radius = radius

RunService.RenderStepped:Connect(function()
    if showRadius then
        local mousePos = UserInputService:GetMouseLocation()
        circle.Visible = true
        circle.Position = Vector2.new(mousePos.X, mousePos.Y)
        circle.Radius = radius
    else
        circle.Visible = false
    end

    -- Ping Prediction logic
    if pingPredictionEnabled then
        local pingStr = Stats.Network.ServerStatsItem["Data Ping"]:GetValueString()
        local pingNum = tonumber(string.match(pingStr, "%d+")) or 0
        predictionAmount = pingNum / 1000 * 1.1 -- adjust multiplier if needed
    end
end)

--Checks


--Visual Tab

local section3 = Visual:Section({
    Name = "Visual",
    Side = "Left",
    Size = 450  -- or any height you want
})

-- Services
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

-- ESP Settings
local espColor = Color3.new(1, 1, 1)
local enabled = false
local boxESPEnabled = false
local healthBarEnabled = false
local displayNameEnabled = false
local usernameEnabled = false
local weaponESPEnabled = false
local distanceEnabled = false
local chamsEnabled = false
local teamCheckEnabled = false

-- Storage
local espVisuals = {}
local espConnections = {}

-- Drawing helper
local function createDrawing(class, props)
    local obj = Drawing.new(class)
    for k, v in pairs(props) do obj[k] = v end
    return obj
end

local function isEnemy(player)
    if not teamCheckEnabled then return true end
    local lp = Players.LocalPlayer
    return lp.Team ~= player.Team
end

local function removeChams(character)
    if not character then return end
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            local cham = part:FindFirstChild("ChamsESP")
            if cham then cham:Destroy() end
        end
    end
end

local function applyChams(character)
    if not character then return end
    for _, part in ipairs(character:GetChildren()) do
        if part:IsA("BasePart") then
            if not part:FindFirstChild("ChamsESP") then
                local box = Instance.new("BoxHandleAdornment")
                box.Name = "ChamsESP"
                box.Adornee = part
                box.AlwaysOnTop = true
                box.ZIndex = 5
                box.Size = part.Size + Vector3.new(0.05, 0.05, 0.05)
                box.Color3 = espColor
                box.Transparency = 0.7
                box.Parent = part
            end
        end
    end
end

local function clearChams()
    for _, player in pairs(Players:GetPlayers()) do
        if player.Character then
            removeChams(player.Character)
        end
    end
end

local function removeVisuals(tbl)
    for _, v in pairs(tbl) do
        if typeof(v) == "table" then
            for _, obj in pairs(v) do 
                if obj and obj.Remove then
                    pcall(function() obj:Remove() end)
                end
            end
        else
            if v and v.Remove then
                pcall(function() v:Remove() end)
            end
        end
    end
end

local function clearESP()
    for _, conn in pairs(espConnections) do
        if conn and conn.Disconnect then
            pcall(function() conn:Disconnect() end)
        end
    end
    espConnections = {}
    for _, visuals in pairs(espVisuals) do
        removeVisuals(visuals)
    end
    espVisuals = {}
    clearChams()
end

local function updateESP(player)
    if player == Players.LocalPlayer then return end

    local visuals = {
        box = createDrawing("Square", {Thickness = 1, Color = espColor, Filled = false, Visible = false}),
        outline = createDrawing("Square", {Thickness = 2, Color = Color3.new(0, 0, 0), Filled = false, Visible = false}),
        healthOutline = createDrawing("Square", {Filled = true, Color = Color3.new(0, 0, 0), Visible = false}),
        health = createDrawing("Square", {Filled = true, Color = espColor, Visible = false}),
        displayName = createDrawing("Text", {Size = 16, Center = true, Outline = true, Color = espColor, Visible = false}),
        username = createDrawing("Text", {Size = 16, Center = true, Outline = true, Color = espColor, Visible = false}),
        weaponName = createDrawing("Text", {Size = 14, Center = true, Outline = true, Color = espColor, Visible = false}),
        distance = createDrawing("Text", {Size = 14, Center = true, Outline = true, Color = espColor, Visible = false}),
    }

    local conn
    conn = RunService.RenderStepped:Connect(function()
        local char = player.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local humanoid = char and char:FindFirstChildOfClass("Humanoid")

        if not enabled or not char or not hrp or not humanoid or humanoid.Health <= 0 then
            for _, obj in pairs(visuals) do obj.Visible = false end
            removeChams(char)
            return
        end

        if not isEnemy(player) then
            for _, obj in pairs(visuals) do obj.Visible = false end
            removeChams(char)
            return
        end

        local pos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
        if not onScreen then
            for _, obj in pairs(visuals) do obj.Visible = false end
            removeChams(char)
            return
        end

        local distance = (Camera.CFrame.Position - hrp.Position).Magnitude
        local size = math.clamp(1000 / distance * 1.7, 10, 220)
        local boxSize = Vector2.new(size, size * 1.5)
        local boxPos = Vector2.new(pos.X - boxSize.X / 2, pos.Y - boxSize.Y / 2)

        -- Box
        visuals.outline.Size = boxSize + Vector2.new(2, 2)
        visuals.outline.Position = boxPos - Vector2.new(1, 1)
        visuals.outline.Visible = boxESPEnabled

        visuals.box.Size = boxSize
        visuals.box.Position = boxPos
        visuals.box.Color = espColor
        visuals.box.Visible = boxESPEnabled

        -- Health
        local healthPct = humanoid.Health / humanoid.MaxHealth
        visuals.healthOutline.Size = Vector2.new(6, boxSize.Y + 2)
        visuals.healthOutline.Position = boxPos - Vector2.new(7, 1)
        visuals.healthOutline.Visible = healthBarEnabled

        visuals.health.Size = Vector2.new(4, boxSize.Y * healthPct)
        visuals.health.Position = boxPos - Vector2.new(6, -boxSize.Y + boxSize.Y * healthPct)
        visuals.health.Color = Color3.fromHSV(healthPct * 0.33, 1, 1)
        visuals.health.Visible = healthBarEnabled

        -- Display Name
        visuals.displayName.Text = player.DisplayName
        visuals.displayName.Position = Vector2.new(pos.X, boxPos.Y - 15)
        visuals.displayName.Visible = displayNameEnabled

        -- Username
        visuals.username.Text = player.Name
        visuals.username.Position = Vector2.new(pos.X, boxPos.Y - 32)
        visuals.username.Visible = usernameEnabled

        -- Weapon
        if weaponESPEnabled then
            local weapon = ""
            for _, item in pairs(char:GetChildren()) do
                if item:IsA("Tool") then
                    weapon = item.Name
                    break
                end
            end
            visuals.weaponName.Text = weapon
            visuals.weaponName.Position = Vector2.new(pos.X, boxPos.Y + boxSize.Y + 5)
            visuals.weaponName.Visible = weapon ~= ""
        else
            visuals.weaponName.Visible = false
        end

        -- Distance
        visuals.distance.Text = string.format("%dm", math.floor(distance))
        visuals.distance.Position = Vector2.new(pos.X, boxPos.Y + boxSize.Y + 20)
        visuals.distance.Visible = distanceEnabled

        -- Chams
        if chamsEnabled then
            applyChams(char)
            for _, part in ipairs(char:GetChildren()) do
                if part:IsA("BasePart") then
                    local cham = part:FindFirstChild("ChamsESP")
                    if cham then
                        cham.Color3 = espColor
                    end
                end
            end
        else
            removeChams(char)
        end
    end)

    espConnections[player] = conn
    espVisuals[player] = visuals
end

local function initESP()
    clearESP()
    for _, player in pairs(Players:GetPlayers()) do updateESP(player) end
    Players.PlayerAdded:Connect(updateESP)
end

-- UI Section3: Hook up your UI buttons
section3:Toggle({ Name = "Enable ESP", Default = false, Callback = function(state) 
    enabled = state 
    if state then 
        initESP() 
    else 
        clearESP() 
    end 
end })
section3:Toggle({ Name = "Box ESP", Default = false, Callback = function(state) boxESPEnabled = state end })
section3:Toggle({ Name = "Health Bar", Default = false, Callback = function(state) healthBarEnabled = state end })
section3:Toggle({ Name = "Display Name", Default = false, Callback = function(state) displayNameEnabled = state end })
section3:Toggle({ Name = "Username", Default = false, Callback = function(state) usernameEnabled = state end })
section3:Toggle({ Name = "Weapon ESP", Default = false, Callback = function(state) weaponESPEnabled = state end })
section3:Toggle({ Name = "Distance", Default = false, Callback = function(state) distanceEnabled = state end })
section3:Toggle({ Name = "Chams ESP", Default = false, Callback = function(state) chamsEnabled = state end }) -- Chams toggle here
section3:Toggle({ Name = "Team Check", Default = false, Callback = function(state) teamCheckEnabled = state end })

-- Color Buttons
local colorPresets = {
    ["White"] = Color3.new(1, 1, 1),
    ["Black"] = Color3.new(0, 0, 0),
    ["Gray"] = Color3.new(0.5, 0.5, 0.5),
    ["Pink"] = Color3.fromRGB(255, 105, 180),
    ["Purple"] = Color3.fromRGB(128, 0, 128),
    ["Orange"] = Color3.fromRGB(255, 165, 0),
}

for name, color in pairs(colorPresets) do
    section3:Button({
        Name = name,
        Callback = function()
            espColor = color
        end
    })
end


--Misc Tab

local section4 = Misc:Section({
    Name = "Exploits",
    Side = "Left",
    Size = 450  -- or any height you want
})

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local localPlayer = Players.LocalPlayer
local humanoid = nil

local speedEnabled = false
local speedValue = 16 -- default Roblox walkspeed

-- Safe Humanoid detection
local function getHumanoid()
	if localPlayer.Character then
		return localPlayer.Character:FindFirstChildOfClass("Humanoid")
	end
	return nil
end

-- Ensure speed doesn't interfere with other movement systems
local function applySpeed()
	if not speedEnabled then return end
	humanoid = getHumanoid()
	if humanoid then
		humanoid.WalkSpeed = speedValue
	end
end

-- Reset speed safely if toggle is off
local function resetSpeed()
	humanoid = getHumanoid()
	if humanoid then
		humanoid.WalkSpeed = 16 -- Default walkspeed
	end
end

-- Setup loop for continuous speed enforcement
RunService.RenderStepped:Connect(function()
	if speedEnabled then
		applySpeed()
	end
end)

-- UI Toggles
section4:Toggle({
	Name = "Speed Hacks",
	Default = false,
	Callback = function(state)
		speedEnabled = state
		if not state then
			resetSpeed()
		end
	end
})

section4:Slider({
	Name = "Speed",
	Min = 0,
	Max = 100,
	Default = 16,
	Callback = function(value)
		speedValue = value
	end
})

--cfly

local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local hrp = character:WaitForChild("HumanoidRootPart")

local flySpeed = 2
local flying = false
local flyConn

-- Direction state
local direction = {
	F = false, B = false, L = false, R = false, U = false, D = false
}

-- Key mapping
local keybinds = {
	[Enum.KeyCode.W] = "F",
	[Enum.KeyCode.S] = "B",
	[Enum.KeyCode.A] = "L",
	[Enum.KeyCode.D] = "R",
	[Enum.KeyCode.Space] = "U",
	[Enum.KeyCode.LeftControl] = "D"
}

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	local dir = keybinds[input.KeyCode]
	if dir then direction[dir] = true end
end)

UserInputService.InputEnded:Connect(function(input)
	local dir = keybinds[input.KeyCode]
	if dir then direction[dir] = false end
end)

local function startCFrameFly()
	local cam = workspace.CurrentCamera

	-- Disable gravity effect
	if character:FindFirstChild("Humanoid") then
		character.Humanoid:ChangeState(Enum.HumanoidStateType.Physics)
	end

	flyConn = RunService.RenderStepped:Connect(function()
		if not character or not hrp then return end

		local moveVec = Vector3.zero
		local cf = cam.CFrame

		if direction.F then moveVec += cf.LookVector end
		if direction.B then moveVec -= cf.LookVector end
		if direction.L then moveVec -= cf.RightVector end
		if direction.R then moveVec += cf.RightVector end
		if direction.U then moveVec += cf.UpVector end
		if direction.D then moveVec -= cf.UpVector end

		if moveVec.Magnitude > 0 then
			hrp.CFrame = hrp.CFrame + moveVec.Unit * flySpeed
		end

		-- Freeze falling
		hrp.Velocity = Vector3.zero
	end)
end

local function stopCFrameFly()
	if flyConn then flyConn:Disconnect() end
	if character:FindFirstChild("Humanoid") then
		character.Humanoid:ChangeState(Enum.HumanoidStateType.GettingUp)
	end
end

-- UI integration
section4:Toggle({
	Name = "CFrame Fly",
	Default = false,
	Callback = function(state)
		flying = state
		character = player.Character or player.CharacterAdded:Wait()
		hrp = character:WaitForChild("HumanoidRootPart")

		if flying then
			startCFrameFly()
		else
			stopCFrameFly()
		end
	end
})

section4:Slider({
	Name = "Fly Speed",
	Min = 1,
	Max = 10,
	Default = 2,
	Callback = function(value)
		flySpeed = value
	end
})

--Noclip

local noclip = false
local noclipConn

local function toggleNoclip(state)
	noclip = state

	if noclip then
		noclipConn = game:GetService("RunService").Stepped:Connect(function()
			local character = player.Character
			if character and character:FindFirstChildOfClass("Humanoid") then
				character:FindFirstChildOfClass("Humanoid"):ChangeState(11)
				for _, part in ipairs(character:GetDescendants()) do
					if part:IsA("BasePart") and part.CanCollide then
						part.CanCollide = false
					end
				end
			end
		end)
	else
		if noclipConn then
			noclipConn:Disconnect()
			noclipConn = nil
		end

		-- Restore CanCollide when turning off
		local character = player.Character
		if character then
			for _, part in ipairs(character:GetDescendants()) do
				if part:IsA("BasePart") then
					part.CanCollide = true
				end
			end
		end
	end
end

section4:Toggle({
	Name = "Noclip",
	Default = false,
	Callback = function(state)
		toggleNoclip(state)
	end
})


--Misc

local section5 = Misc:Section({
    Name = "Misc",
    Side = "Right",
    Size = 450  -- or any height you want
})

local hoverEnabled = false
local hoverConnection

section5:Toggle({ 
    Name = "Hover Info", 
    Default = false,
    Callback = function(state)
        hoverEnabled = state
        
        if hoverConnection then
            hoverConnection:Disconnect()
            hoverConnection = nil
        end
        
        if hoverEnabled then
            -- Set up the UI only once
            local Players = game:GetService("Players")
            local RunService = game:GetService("RunService")
            local LocalPlayer = Players.LocalPlayer
            local Mouse = LocalPlayer:GetMouse()
            local Camera = workspace.CurrentCamera

            local MaxDistance = 80
            local accentColor = Color3.fromRGB(130, 50, 180)

            -- Create UI
            local ScreenGui = Instance.new("ScreenGui")
            ScreenGui.Name = "HoverInfoGui"
            ScreenGui.ResetOnSpawn = false
            ScreenGui.IgnoreGuiInset = true
            pcall(function() ScreenGui.Parent = game:GetService("CoreGui") end)
            if not ScreenGui.Parent then
                ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")
            end

            local frame = Instance.new("Frame")
            frame.Size = UDim2.new(0, 300, 0, 100)
            frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
            frame.BorderSizePixel = 0
            frame.AnchorPoint = Vector2.new(0.5, 1)
            frame.Position = UDim2.new(0.5, 0, 0.5, 0)
            frame.Visible = false
            frame.BackgroundTransparency = 0.1
            frame.Parent = ScreenGui
            Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 8)
            local stroke = Instance.new("UIStroke", frame)
            stroke.Color = Color3.new(0, 0, 0)
            stroke.Thickness = 2
            stroke.Transparency = 0.6

            local avatar = Instance.new("ImageLabel", frame)
            avatar.Size = UDim2.new(0, 60, 0, 60)
            avatar.Position = UDim2.new(0, 10, 0, 20)
            avatar.BackgroundTransparency = 1
            avatar.Image = ""
            avatar.ScaleType = Enum.ScaleType.Fit
            Instance.new("UICorner", avatar).CornerRadius = UDim.new(1, 0)

            local username = Instance.new("TextLabel", frame)
            username.Text = "Username"
            username.Font = Enum.Font.GothamSemibold
            username.TextSize = 14
            username.TextColor3 = Color3.fromRGB(225, 225, 225)
            username.BackgroundTransparency = 1
            username.Position = UDim2.new(0, 80, 0, 20)
            username.Size = UDim2.new(1, -90, 0, 20)
            username.TextXAlignment = Enum.TextXAlignment.Left

            local displayName = Instance.new("TextLabel", frame)
            displayName.Text = "DisplayName"
            displayName.Font = Enum.Font.Gotham
            displayName.TextSize = 13
            displayName.TextColor3 = Color3.fromRGB(170, 170, 170)
            displayName.BackgroundTransparency = 1
            displayName.Position = UDim2.new(0, 80, 0, 40)
            displayName.Size = UDim2.new(1, -90, 0, 18)
            displayName.TextXAlignment = Enum.TextXAlignment.Left

            local healthBarBg = Instance.new("Frame", frame)
            healthBarBg.Size = UDim2.new(0.65, 0, 0, 6)
            healthBarBg.Position = UDim2.new(0, 80, 1, -15)
            healthBarBg.BackgroundColor3 = Color3.fromRGB(35, 35, 35)
            healthBarBg.BorderSizePixel = 0
            Instance.new("UICorner", healthBarBg).CornerRadius = UDim.new(0, 4)

            local healthBar = Instance.new("Frame", healthBarBg)
            healthBar.Size = UDim2.new(1, 0, 1, 0)
            healthBar.Position = UDim2.new(0, 0, 0, 0)
            healthBar.BackgroundColor3 = accentColor
            healthBar.BorderSizePixel = 0
            Instance.new("UICorner", healthBar).CornerRadius = UDim.new(0, 4)

            local function updateHoverInfo(char, player)
                local head = char:FindFirstChild("Head")
                if not head then return end

                username.Text = player.Name
                displayName.Text = player.DisplayName

                avatar.Image = string.format("https://www.roblox.com/headshot-thumbnail/image?userId=%s&width=420&height=420&format=png", player.UserId)

                local humanoid = char:FindFirstChildOfClass("Humanoid")
                if humanoid then
                    local ratio = humanoid.Health / humanoid.MaxHealth
                    healthBar.Size = UDim2.new(math.clamp(ratio, 0, 1), 0, 1, 0)
                end
            end

            hoverConnection = RunService.RenderStepped:Connect(function()
                if not hoverEnabled then
                    frame.Visible = false
                    return
                end

                local target = Mouse.Target
                if target then
                    local char = target:FindFirstAncestorOfClass("Model")
                    local player = Players:GetPlayerFromCharacter(char)
                    if player and player ~= LocalPlayer then
                        local head = char:FindFirstChild("Head")
                        if head then
                            local distance = (Camera.CFrame.Position - head.Position).Magnitude
                            if distance <= MaxDistance then
                                local pos, onScreen = Camera:WorldToViewportPoint(head.Position + Vector3.new(0, 2.5, 0))
                                if onScreen then
                                    updateHoverInfo(char, player)
                                    frame.Position = UDim2.new(0, pos.X, 0, pos.Y)
                                    frame.Visible = true
                                    return
                                end
                            end
                        end
                    end
                end
                frame.Visible = false
            end)
        else
            -- Clean up UI on disable
            local existingGui = ScreenGui or game:GetService("CoreGui"):FindFirstChild("HoverInfoGui") or LocalPlayer.PlayerGui:FindFirstChild("HoverInfoGui")
            if existingGui then
                existingGui:Destroy()
            end
            frame = nil
        end
    end
})
